// Code generated by "enumerator -type Type -linecomment -trimprefix"; DO NOT EDIT.

package actor

import (
	"fmt"
	"strconv"
)

func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[TypeNone-0]
	_ = x[TypeDonor-1]
	_ = x[TypeAttorney-2]
	_ = x[TypeReplacementAttorney-3]
	_ = x[TypeCertificateProvider-4]
	_ = x[TypePersonToNotify-5]
	_ = x[TypeAuthorisedSignatory-6]
	_ = x[TypeIndependentWitness-7]
	_ = x[TypeTrustCorporation-8]
	_ = x[TypeReplacementTrustCorporation-9]
	_ = x[TypeVoucher-10]
	_ = x[TypeCorrespondent-11]
}

const _Type_name = "NonedonorattorneyreplacementAttorneycertificateProviderpersonToNotifysignatoryindependentWitnesstrustCorporationreplacementTrustCorporationvouchercorrespondent"

var _Type_index = [...]uint8{0, 4, 9, 17, 36, 55, 69, 78, 96, 112, 139, 146, 159}

func (i Type) String() string {
	if i >= Type(len(_Type_index)-1) {
		return "Type(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _Type_name[_Type_index[i]:_Type_index[i+1]]
}

func (i Type) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

func (i *Type) UnmarshalText(text []byte) error {
	val, err := ParseType(string(text))
	if err != nil {
		return err
	}

	*i = val
	return nil
}

func (i Type) IsNone() bool {
	return i == TypeNone
}

func (i Type) IsDonor() bool {
	return i == TypeDonor
}

func (i Type) IsAttorney() bool {
	return i == TypeAttorney
}

func (i Type) IsReplacementAttorney() bool {
	return i == TypeReplacementAttorney
}

func (i Type) IsCertificateProvider() bool {
	return i == TypeCertificateProvider
}

func (i Type) IsPersonToNotify() bool {
	return i == TypePersonToNotify
}

func (i Type) IsAuthorisedSignatory() bool {
	return i == TypeAuthorisedSignatory
}

func (i Type) IsIndependentWitness() bool {
	return i == TypeIndependentWitness
}

func (i Type) IsTrustCorporation() bool {
	return i == TypeTrustCorporation
}

func (i Type) IsReplacementTrustCorporation() bool {
	return i == TypeReplacementTrustCorporation
}

func (i Type) IsVoucher() bool {
	return i == TypeVoucher
}

func (i Type) IsCorrespondent() bool {
	return i == TypeCorrespondent
}

func ParseType(s string) (Type, error) {
	switch s {
	case "None":
		return TypeNone, nil
	case "donor":
		return TypeDonor, nil
	case "attorney":
		return TypeAttorney, nil
	case "replacementAttorney":
		return TypeReplacementAttorney, nil
	case "certificateProvider":
		return TypeCertificateProvider, nil
	case "personToNotify":
		return TypePersonToNotify, nil
	case "signatory":
		return TypeAuthorisedSignatory, nil
	case "independentWitness":
		return TypeIndependentWitness, nil
	case "trustCorporation":
		return TypeTrustCorporation, nil
	case "replacementTrustCorporation":
		return TypeReplacementTrustCorporation, nil
	case "voucher":
		return TypeVoucher, nil
	case "correspondent":
		return TypeCorrespondent, nil
	default:
		return Type(0), fmt.Errorf("invalid Type '%s'", s)
	}
}

type TypeOptions struct {
	None                        Type
	Donor                       Type
	Attorney                    Type
	ReplacementAttorney         Type
	CertificateProvider         Type
	PersonToNotify              Type
	AuthorisedSignatory         Type
	IndependentWitness          Type
	TrustCorporation            Type
	ReplacementTrustCorporation Type
	Voucher                     Type
	Correspondent               Type
}

var TypeValues = TypeOptions{
	None:                        TypeNone,
	Donor:                       TypeDonor,
	Attorney:                    TypeAttorney,
	ReplacementAttorney:         TypeReplacementAttorney,
	CertificateProvider:         TypeCertificateProvider,
	PersonToNotify:              TypePersonToNotify,
	AuthorisedSignatory:         TypeAuthorisedSignatory,
	IndependentWitness:          TypeIndependentWitness,
	TrustCorporation:            TypeTrustCorporation,
	ReplacementTrustCorporation: TypeReplacementTrustCorporation,
	Voucher:                     TypeVoucher,
	Correspondent:               TypeCorrespondent,
}
